---
date: 2025-07-19
categories:
  - 多线程
---
# 锁、原子变量、条件变量

<!-- more -->
## 锁

锁（Mutex）用于保护临界区，防止多个线程同时访问共享资源，保证数据一致性。

### 底层实现

- 常见实现方式有自旋锁（spinlock）、互斥锁（mutex）、读写锁（rwlock）等。
- 操作系统通常通过原子指令（如CAS、Test-and-Set）和信号量实现锁机制。
- 用户态锁（如C++11的`std::mutex`）通常封装了操作系统的互斥量（如Windows的Critical Section、Linux的pthread_mutex_t）。

### 重入锁

- 重入锁（Recursive Lock）允许同一线程多次获得同一把锁，不会发生死锁。
- 典型实现是为每个锁记录拥有者线程ID和重入次数。
- 适用场景：递归调用、同一线程多次加锁。

### 非重入锁

- 非重入锁（Non-Recursive Lock）同一线程不能重复获得锁，否则会死锁。
- 适用场景：简单的互斥保护，无递归需求。

## 原子变量

原子变量（Atomic Variable）是一种特殊类型的变量，支持原子操作，保证并发环境下的读写安全，无需加锁。

### 底层实现

- 依赖于CPU提供的原子指令（如x86的`LOCK`前缀、ARM的`LDREX/STREX`）。
- C++11提供`std::atomic`，Java提供`AtomicInteger`等。
- 原子操作包括原子读写、原子加减、CAS（Compare And Swap）等。

## 条件变量

条件变量（Condition Variable）用于线程间同步，允许线程在某个条件满足前进入等待状态。

### 底层实现

- 通常与互斥锁配合使用。
- 操作系统实现如pthread_cond_t（Linux）、ConditionVariable（Windows）。
- 线程调用`wait()`进入等待，其他线程调用`notify_one()`或`notify_all()`唤醒。

### 假醒
### **一、假醒的本质原因**
假醒的根源与操作系统的线程调度和条件变量的底层实现有关：
1. **内核级等待队列的特性**：  
   条件变量的等待队列由操作系统内核维护，当线程调用`wait`时，会被放入队列并阻塞。内核在某些情况下（如信号中断、线程调度冲突、队列状态异常）可能会“意外”唤醒线程，即使没有收到`notify`信号。  
   - 例如，Linux的`pthread_cond_wait`可能因系统信号（如`SIGINT`）中断等待，导致线程提前唤醒。

2. **性能与正确性的权衡**：  
   操作系统为了简化条件变量的实现（或优化性能），不保证“只有`notify`能唤醒线程”。强制避免假醒会增加内核复杂度（如跟踪每个唤醒的来源），反而降低效率。因此，标准允许假醒存在，将处理责任交给用户态代码。



```cpp
void worker() {
    std::unique_lock<std::mutex> lock(mtx);
    // 关键：用while循环而非if，重新检查条件
    while (!ready) {  // 若假醒，会重新判断条件
        cv.wait(lock);  // 释放锁并等待，被唤醒后重新加锁
    }
    // 条件满足后执行操作
}
```

## 各自的使用场景

- **锁**：保护临界区，防止数据竞争，适用于需要互斥访问的场景。
- **原子变量**：适用于简单的计数器、自增、自减等无需复杂同步的场景，性能优于锁。
- **条件变量**：适用于线程间需要等待某个条件成立再继续执行的场景，如生产者-消费者



